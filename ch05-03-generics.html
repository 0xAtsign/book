<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-01-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-02-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-03-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li><li><a href="ch01-04-design.html"><strong>1.3.</strong> The Design of Rust</a></li></ul></li><li><strong>2.</strong> Tutorial</li><li><a href="ch03-01-up-and-running.html"><strong>3.</strong> Up and Running</a></li><li><ul class="section"><li><a href="ch03-02-variable-bindings.html"><strong>3.1.</strong> Variable Bindings</a></li><li><a href="ch03-03-functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="ch03-04-scalar-types.html"><strong>3.3.</strong> Scalar Types</a></li><li><a href="ch03-05-compound-types.html"><strong>3.4.</strong> Compound Types</a></li><li><a href="ch03-06-comments.html"><strong>3.5.</strong> Comments</a></li><li><a href="ch03-07-if.html"><strong>3.6.</strong> Control flow with <code>if</code></a></li><li><a href="ch03-08-loops.html"><strong>3.7.</strong> Loops</a></li></ul></li><li><a href="ch04-01-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-02-ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="ch04-03-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-04-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-01-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-02-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li><li><a href="ch05-03-generics.html" class="active"><strong>5.2.</strong> Generics</a></li><li><strong>5.3.</strong> Advanced</li></ul></li><li><a href="ch06-01-enums.html"><strong>6.</strong> Enums</a></li><li><ul class="section"><li><a href="ch06-02-option.html"><strong>6.1.</strong> Option</a></li><li><a href="ch06-03-match.html"><strong>6.2.</strong> Match</a></li><li><a href="ch06-04-if-let.html"><strong>6.3.</strong> if let</a></li><li><a href="ch06-05-patterns.html"><strong>6.4.</strong> Patterns</a></li></ul></li><li><strong>7.</strong> Crates &amp; Modules</li><li><strong>8.</strong> Error Handling</li><li><strong>9.</strong> Basic Collections</li><li><ul class="section"><li><strong>9.1.</strong> Vectors</li><li><strong>9.2.</strong> Strings</li><li><strong>9.3.</strong> <code>HashMap&lt;K, V&gt;</code></li></ul></li><li><strong>10.</strong> Lifetimes</li><li><strong>11.</strong> Traits</li><li><strong>12.</strong> Closures</li><li><strong>13.</strong> Iterators</li><li><strong>14.</strong> I/O</li><li><ul class="section"><li><strong>14.1.</strong> <code>Read</code> &amp; <code>Write</code></li><li><strong>14.2.</strong> <code>std::fs</code></li><li><strong>14.3.</strong> <code>std::path</code></li><li><strong>14.4.</strong> <code>std::env</code></li></ul></li><li><strong>15.</strong> Testing</li><li><strong>16.</strong> Smart Pointers</li><li><ul class="section"><li><strong>16.1.</strong> <code>Deref</code></li><li><strong>16.2.</strong> <code>Deref</code> coercions</li><li><strong>16.3.</strong> <code>Box&lt;T&gt;</code></li><li><strong>16.4.</strong> <code>Rc&lt;T&gt;</code></li></ul></li><li><strong>17.</strong> Concurrency</li><li><ul class="section"><li><strong>17.1.</strong> Threads</li><li><strong>17.2.</strong> <code>Send</code> &amp; <code>Sync</code></li><li><strong>17.3.</strong> <code>Arc&lt;T&gt;</code></li><li><strong>17.4.</strong> <code>Mutex&lt;T&gt;</code></li><li><strong>17.5.</strong> <code>Channels</code></li></ul></li><li><strong>18.</strong> Unsafe Rust</li><li><ul class="section"><li><strong>18.1.</strong> Raw Pointers</li><li><strong>18.2.</strong> transmute</li></ul></li><li><strong>19.</strong> FFI</li><li><ul class="section"><li><strong>19.1.</strong> Conditional Compilation</li><li><strong>19.2.</strong> Bindings to C</li><li><strong>19.3.</strong> Using Rust from Other Languages</li><li><strong>19.4.</strong> <code>static</code></li></ul></li><li><strong>20.</strong> Cargo</li><li><ul class="section"><li><strong>20.1.</strong> Crates.io</li></ul></li><li><strong>21.</strong> Advanced Type System Features</li><li><ul class="section"><li><strong>21.1.</strong> Associated Types</li><li><strong>21.2.</strong> Trait Objects</li><li><strong>21.3.</strong> UFCS</li><li><strong>21.4.</strong> Coherence</li></ul></li><li><strong>22.</strong> Interior mutability</li><li><ul class="section"><li><strong>22.1.</strong> <code>Cell&lt;T&gt;</code></li><li><strong>22.2.</strong> <code>RefCell&lt;T&gt;</code></li></ul></li><li><strong>23.</strong> Macros</li><li><strong>24.</strong> Nightly Rust</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Generics</h1>
<p>We've been working with a <code>Point</code> struct that looks like this:</p>
<pre><code class="language-rust">#[derive(Debug,Copy,Clone)]
struct Point {
    x: f64,
    y: f64,
}
</code></pre>
<p>But what if we didn't want to always use an <code>f64</code> here? What about an <code>f32</code> for
when we need less precision? Or an <code>i32</code> if we only want integer coordinates?</p>
<p>While our simple <code>Point</code> struct may be a bit too simple to bother making
generic in a real application, we're going to stick with it to show you the
syntax. Especially when building library code, generics allow for more code
re-use, and unlock a lot of powerful techniques.</p>
<h2>Generic data types</h2>
<p>'Generics' let us write code that allows for several different types, while
letting us have one definition. A more generic <code>Point</code> would look like this:</p>
<pre><code class="language-rust">#[derive(Debug,Copy,Clone)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}
</code></pre>
<p>There are two changes here, and they both involve this new <code>T</code>. The first change
is in the definition:</p>
<pre><code class="language-rust"># #[derive(Debug,Copy,Clone)]
struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
</code></pre>
<p>Our previous definition said, &quot;We are defining a struct named Point.&quot; This
definition says something slightly different: &quot;We are defining a struct named
Point with one type parameter <code>T</code>.&quot;</p>
<p>Let's talk about this term 'type parameter'. We've already seen one other thing
called a 'parameter' in Rust: function parameters:</p>
<pre><code class="language-rust">fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Here, <code>x</code> is a parameter to this function. We can call this function with a
different value, and <code>x</code> will change each time it's called:</p>
<pre><code class="language-rust"># fn plus_one(x: i32) -&gt; i32 {
#     x + 1
# }
let six = plus_one(5);
let eleven = plus_one(10);
</code></pre>
<p>In the same way, a type parameter allows us to define a data type which can be
different each time we use it:</p>
<pre><code class="language-rust">#[derive(Debug,Copy,Clone)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let integral_point = Point { x: 5, y: 5 };
let floating_point = Point { x: 5.0, y: 5.0 };
</code></pre>
<p>Here, <code>integral_point</code> uses <code>i32</code> values for <code>T</code>, and <code>floating_point</code> uses
<code>f64</code> values. This also leads us to talk about the second change we made to <code>Point</code>:</p>
<pre><code class="language-rust"># #[derive(Debug,Copy,Clone)]
# struct Point&lt;T&gt; {
    x: T,
    y: T,
# }
</code></pre>
<p>Instead of saying <code>x: i32</code>, we say <code>x: T</code>. This <code>T</code> is the same one that we
used above in the struct declaration. Because <code>x</code> and <code>y</code> both use <code>T</code>, they'll
be the same type. We could give them different types:</p>
<pre><code class="language-rust">#[derive(Debug,Copy,Clone)]
struct Point&lt;T, OtherT&gt; {
    x: T,
    y: OtherT,
}

let different = Point { x: 5, y: 5.0 };
let same = Point { x: 5.0, y: 5.0 };
</code></pre>
<p>Here, instead of a single parameter, <code>T</code>, we have two: <code>T</code> and <code>OtherT</code>. Type
parameters have the same naming convention as other types: <code>CamelCase</code>.
However, you'll often see short, one-letter names used for types. <code>T</code> is very
common, because it's short for 'type', but you can name them something longer
if you'd like. In this version of <code>Point</code>, we say that <code>x</code> has the type <code>T</code>,
and <code>y</code> has the type <code>OtherT</code>. This lets us give them two different types, but
they don't have to be.</p>
<h2>Generic functions</h2>
<p>Regular old functions can also take generic parameters, with a syntax that looks
very similar:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;(x: T) {
    // ...
}
</code></pre>
<p>This <code>foo()</code> function has one generic parameter, <code>T</code>, and takes one argument,
<code>x</code>, which has the type <code>T</code>. Let's talk a little bit more about what this means.</p>
<h2>Generic methods</h2>
<p>We've seen how to define methods with the <code>impl</code> keyword. Our generic <code>Point</code>
can have generic methods, too:</p>
<pre><code class="language-rust">#[derive(Debug,Copy,Clone)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn some_method(&amp;self) {
        // ...
    }
}
</code></pre>
<p>We also need the <code>&lt;T&gt;</code> after <code>impl</code>. This line reads, &quot;We will be implementing
methods with one generic type parameter, <code>T</code>, for a type, <code>Point</code>, which takes
one generic type <code>T</code>.&quot; In a sense, the <code>impl&lt;T&gt;</code> says &quot;we will be using a type
<code>T</code>&quot; and the <code>Point&lt;T&gt;</code> says &quot;that <code>T</code> is used for <code>Point</code>.&quot; In this simple
case, this syntax can feel a bit redundant, but when we get into some of Rust's
more advanced features later, this distinction will become more useful.</p>
<h2>There's more to the story</h2>
<p>This section covered the basic syntax of generics, but it's not the full story.
For example, let's try to implement our <code>foo()</code> function: we'll have it print out
the value of <code>x</code>:</p>
<pre><code class="language-rust,ignore">fn foo&lt;T&gt;(x: T) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre>
<p>We'll get an error:</p>
<pre><code class="language-text">error: the trait `core::fmt::Display` is not implemented for the type `T` [E0277]
println!(&quot;x is: {}&quot;, x);
                     ^
</code></pre>
<p>We can't print out <code>x</code>! The error messages reference something we talked about
briefly before, the <code>Display</code> trait. In order to implement this function, we
need to talk about traits. But we only need to talk about traits to implement
our own generic functions; we don't need this understanding to use them. So
rather than get into more details about this right now, let's talk about other
useful Rust data types, and we can come back to implementing generic functions
in the chapter about traits.</p>
<p>For now, the important bits to understand:</p>
<ul>
<li>Generic type parameters are kind of like function parameters, but for types
instead of values.</li>
<li>Type parameters go inside <code>&lt;&gt;</code>s and are usually named things like <code>T</code>.</li>
</ul>
<p>With that, let's talk about another fundamental Rust data type: enums.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch05-02-method-syntax.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch06-01-enums.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch05-02-method-syntax.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch06-01-enums.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>

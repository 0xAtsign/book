<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts-in-rust.html"><strong>3.</strong> Common Programming Concepts in Rust</a></li><li><ul class="section"><li><a href="ch03-01-variable-bindings-and-mutability.html"><strong>3.1.</strong> Variable Bindings and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums</a></li><li><ul class="section"><li><a href="ch06-01-option.html" class="active"><strong>6.1.</strong> Option</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> Match</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> Modules</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> Controlling Visibility with <code>pub</code></a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-fundamental-collections.html"><strong>8.</strong> Fundamental Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><strong>9.</strong> Error Handling</li><li><strong>10.</strong> Generics</li><li><strong>11.</strong> Iterators</li><li><strong>12.</strong> I/O</li><li><ul class="section"><li><strong>12.1.</strong> <code>Read</code> &amp; <code>Write</code></li><li><strong>12.2.</strong> <code>std::fs</code></li><li><strong>12.3.</strong> <code>std::path</code></li><li><strong>12.4.</strong> <code>std::env</code></li></ul></li><li><a href="chXX-patterns.html"><strong>13.</strong> Patterns</a></li><li><strong>14.</strong> Testing</li><li><strong>15.</strong> Debugging</li><li><strong>16.</strong> Composition</li><li><strong>17.</strong> Closures</li><li><strong>18.</strong> Zero-cost Abstractions</li><li><ul class="section"><li><strong>18.1.</strong> Iterators as a Case Study</li></ul></li><li><strong>19.</strong> Creating a Library</li><li><ul class="section"><li><strong>19.1.</strong> Cargo</li><li><strong>19.2.</strong> Crates.io</li><li><a href="chYY-YY-public-api.html"><strong>19.3.</strong> Organizing your Public API</a></li><li><a href="chYY-YY-documentation.html"><strong>19.4.</strong> Documentation</a></li><li><a href="chYY-YY-workspaces.html"><strong>19.5.</strong> Workspaces and Multiple Related Crates</a></li></ul></li><li><strong>20.</strong> Smart Pointers</li><li><ul class="section"><li><strong>20.1.</strong> <code>Deref</code></li><li><strong>20.2.</strong> <code>Deref</code> Coercions</li><li><strong>20.3.</strong> <code>Box&lt;T&gt;</code></li><li><strong>20.4.</strong> <code>Rc&lt;T&gt;</code></li></ul></li><li><strong>21.</strong> Concurrency</li><li><ul class="section"><li><strong>21.1.</strong> Threads</li><li><strong>21.2.</strong> <code>Send</code> &amp; <code>Sync</code></li><li><strong>21.3.</strong> <code>Arc&lt;T&gt;</code></li><li><strong>21.4.</strong> <code>Mutex&lt;T&gt;</code></li><li><strong>21.5.</strong> <code>Channels</code></li></ul></li><li><strong>22.</strong> Unsafe Rust</li><li><ul class="section"><li><strong>22.1.</strong> Raw Pointers</li><li><strong>22.2.</strong> <code>transmute</code></li></ul></li><li><strong>23.</strong> FFI</li><li><ul class="section"><li><strong>23.1.</strong> Conditional Compilation</li><li><strong>23.2.</strong> Bindings to C</li><li><strong>23.3.</strong> Using Rust from Other Languages</li><li><strong>23.4.</strong> <code>static</code></li></ul></li><li><strong>24.</strong> Advanced Type System Features</li><li><ul class="section"><li><strong>24.1.</strong> Associated Types</li><li><strong>24.2.</strong> Trait Objects</li><li><strong>24.3.</strong> UFCS</li><li><strong>24.4.</strong> Coherence</li></ul></li><li><strong>25.</strong> Interior Mutability</li><li><ul class="section"><li><strong>25.1.</strong> <code>Cell&lt;T&gt;</code></li><li><strong>25.2.</strong> <code>RefCell&lt;T&gt;</code></li></ul></li><li><strong>26.</strong> Macros</li><li><strong>27.</strong> Nightly Rust</li><li><a href="appendix-00.html"><strong>28.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>28.1.</strong> Keywords</a></li><li><a href="appendix-02-derivable-traits.html"><strong>28.2.</strong> Derivable Traits</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h2>Option</h2>
<p>Now that we have had an introduction to enums, let's combine them with a
feature that we talked a little bit about in the previous chapter: generics.</p>
<p>Programming language design is often thought of as which features you include,
but it's also about which features you leave out. Rust does not have a feature
that is in many other languages: <em>null</em>. In languages with this feature,
variables can have two states: null or not-null.</p>
<p>The inventor of this concept has this to say:</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My
goal was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn't resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in
the last forty years.</p>
<ul>
<li>Tony Hoare &quot;Null References: The Billion Dollar Mistake&quot;</li>
</ul>
</blockquote>
<p>The problem with null values is twofold: first, a value can be null or not, at
any time. The second is that if you try to use a value that's null, you'll get
an error of some kind, depending on the language. Because this property is
pervasive, it's extremely easy to make this kind of error.</p>
<p>Even with these problems, the concept that null is trying to express is still a
useful one: this is a value which is currently invalid or not present for some
reason. The problem isn't with the concept itself, but with the particular
implementation. As such, Rust does not have the concept of null, but we do have
an enum which can encode the concept of a value being present or not present. We
call this enum <code>Option&lt;T&gt;</code>, and it looks like this:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
<p>This enum is <a href="../std/option/enum.Option.html">provided by the standard library</a><!-- ignore -->, and is
so useful that it's even in the prelude; you don't need to import it
explicitly. Furthermore, so are its variants: you can say <code>Some</code> and <code>None</code>
directly, without prefixing them with <code>Option::</code>.</p>
<p>Here's an example of using <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-rust">let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

// If we only say None, we need to tell Rust what type of Option&lt;T&gt; we have.
let absent_number: Option&lt;i32&gt; = None;
</code></pre>
<p>Let's dig in. First, you'll notice that we used the <code>&lt;T&gt;</code> syntax when defining
<code>Option&lt;T&gt;</code>: it's a generic enum. <code>Option&lt;T&gt;</code> has two variants: <code>Some</code>, which
contains a <code>T</code>, and <code>None</code>, which has no data associated with it. In some
sense, <code>None</code> means &quot;null&quot;, and <code>Some</code> means &quot;not null&quot;. So why is this any
better than null?</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> are different types. That's a bit too
short though. Here's an example:</p>
<pre><code class="language-rust,ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>This will not compile. We get an error message like this:</p>
<pre><code class="language-bash">error: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not
satisfied [E0277]

let sum = x + y;
          ^~~~~
</code></pre>
<p>Intense! What this error message is trying to say is that Rust does not
understand how to add an <code>Option&lt;T&gt;</code> and a <code>T</code>. They're different types! This
shows one of the big advantages of an <code>Option&lt;T&gt;</code>: if you have a value that
may or may not exist, you have to deal with that fact before you can assume it
exists. In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you
can do <code>T</code> stuff with it. This helps catch one of the most common issues with
null, generally: assuming that something isn't null when it actually is.</p>
<p>This is pretty powerful: in order to have a value that can possibly be null,
you have to explicitly opt in by making the type of that value an <code>Option&lt;T&gt;</code>.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn't an
<code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn't null. This was a
deliberate design decision for Rust to limit null's pervasiveness and increase
the safety of Rust code.</p>
<p>So, how <em>do</em> you get a <code>T</code> from an <code>Option&lt;T&gt;</code>?  The <code>Option&lt;T&gt;</code> enum has a
large number of methods that you can check out in
<a href="../std/option/enum.Option.html">its documentation</a><!-- ignore -->, and becoming familiar with them will
be extremely useful in your journey with Rust.</p>
<p>But we want a deeper understanding than that. If we didn't have those methods
defined for us already, what would we do? And more generally, how do we get
the inner values out of any enum variant? We need a new feature: <code>match</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch06-00-enums.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch06-02-match.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch06-00-enums.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch06-02-match.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>

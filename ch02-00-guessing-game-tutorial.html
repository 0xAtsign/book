<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts-in-rust.html"><strong>3.</strong> Common Programming Concepts in Rust</a></li><li><ul class="section"><li><a href="ch03-01-variable-bindings-and-mutability.html"><strong>3.1.</strong> Variable Bindings and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums</a></li><li><ul class="section"><li><a href="ch06-01-option.html"><strong>6.1.</strong> Option</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> Match</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> if let</a></li></ul></li><li><strong>7.</strong> Crates &amp; Modules</li><li><strong>8.</strong> Basic Collections</li><li><ul class="section"><li><strong>8.1.</strong> Vectors</li><li><strong>8.2.</strong> Strings</li><li><strong>8.3.</strong> <code>HashMap&lt;K, V&gt;</code></li></ul></li><li><strong>9.</strong> Error Handling</li><li><strong>10.</strong> Lifetimes</li><li><a href="chZZ-generics.html"><strong>11.</strong> Generics</a></li><li><strong>12.</strong> Traits</li><li><strong>13.</strong> Closures</li><li><strong>14.</strong> Iterators</li><li><a href="chXX-patterns.html"><strong>15.</strong> Patterns</a></li><li><strong>16.</strong> I/O</li><li><ul class="section"><li><strong>16.1.</strong> <code>Read</code> &amp; <code>Write</code></li><li><strong>16.2.</strong> <code>std::fs</code></li><li><strong>16.3.</strong> <code>std::path</code></li><li><strong>16.4.</strong> <code>std::env</code></li></ul></li><li><strong>17.</strong> Testing</li><li><strong>18.</strong> Debugging</li><li><strong>19.</strong> Smart Pointers</li><li><ul class="section"><li><strong>19.1.</strong> <code>Deref</code></li><li><strong>19.2.</strong> <code>Deref</code> coercions</li><li><strong>19.3.</strong> <code>Box&lt;T&gt;</code></li><li><strong>19.4.</strong> <code>Rc&lt;T&gt;</code></li></ul></li><li><strong>20.</strong> Concurrency</li><li><ul class="section"><li><strong>20.1.</strong> Threads</li><li><strong>20.2.</strong> <code>Send</code> &amp; <code>Sync</code></li><li><strong>20.3.</strong> <code>Arc&lt;T&gt;</code></li><li><strong>20.4.</strong> <code>Mutex&lt;T&gt;</code></li><li><strong>20.5.</strong> <code>Channels</code></li></ul></li><li><strong>21.</strong> Unsafe Rust</li><li><ul class="section"><li><strong>21.1.</strong> Raw Pointers</li><li><strong>21.2.</strong> transmute</li></ul></li><li><strong>22.</strong> FFI</li><li><ul class="section"><li><strong>22.1.</strong> Conditional Compilation</li><li><strong>22.2.</strong> Bindings to C</li><li><strong>22.3.</strong> Using Rust from Other Languages</li><li><strong>22.4.</strong> <code>static</code></li></ul></li><li><strong>23.</strong> Creating a Library</li><li><ul class="section"><li><strong>23.1.</strong> Cargo</li><li><strong>23.2.</strong> Crates.io</li><li><a href="chYY-YY-documentation.html"><strong>23.3.</strong> Documentation</a></li><li><a href="chYY-YY-workspaces.html"><strong>23.4.</strong> Workspaces and Multiple Related Crates</a></li></ul></li><li><strong>24.</strong> Advanced Type System Features</li><li><ul class="section"><li><strong>24.1.</strong> Associated Types</li><li><strong>24.2.</strong> Trait Objects</li><li><strong>24.3.</strong> UFCS</li><li><strong>24.4.</strong> Coherence</li></ul></li><li><strong>25.</strong> Interior mutability</li><li><ul class="section"><li><strong>25.1.</strong> <code>Cell&lt;T&gt;</code></li><li><strong>25.2.</strong> <code>RefCell&lt;T&gt;</code></li></ul></li><li><strong>26.</strong> Macros</li><li><strong>27.</strong> Nightly Rust</li><li><a href="appendix-00.html"><strong>28.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>28.1.</strong> Keywords</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Guessing Game</h1>
<p>Let's jump into Rust with a hands-on project! This chapter will introduce you to
a few common Rust concepts by showing how you would use them in a real program.
You'll learn about <code>let</code>, <code>match</code>, methods, associated functions, using
external crates, and more! Following chapters will explore these ideas in more
detail.</p>
<p>We’re going to implement a classic beginner programming problem: the guessing
game. Here’s how it works: Our program will generate a random integer between
one and a hundred. It will then prompt us to enter a guess. Upon entering our
guess, it will tell us if we’re too low or too high. Once we guess correctly,
it will congratulate us.</p>
<h2>Setting Up a New Project</h2>
<p>Let’s set up a new project. Go to your projects directory from the previous
chapter, and create a new project using Cargo, like so:</p>
<pre><code class="language-bash">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>We pass the name of our project to <code>cargo new</code> and pass the <code>--bin</code> flag, since
we’re going to be making another binary like in Chapter 1.</p>
<p>Take a look at the generated <code>Cargo.toml</code>:</p>
<p>Filename: Cargo.toml</p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>If the author information that Cargo got from your environment is not correct,
go ahead and fix that in the file and save it again.</p>
<p>And as we saw in the last chapter, <code>cargo new</code> generates a &quot;Hello, world!&quot;
program for us. Check out <code>src/main.rs</code>:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Let’s try compiling what Cargo gave us and running it in the same step, using
the <code>cargo run</code> command:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Great! The <code>run</code> command comes in handy when you need to rapidly iterate on a
project. Our game is such a project: we want to quickly test each
iteration before moving on to the next one.</p>
<p>Now open up your <code>src/main.rs</code> again. We’ll be writing all of our code in this
file.</p>
<h2>Processing a Guess</h2>
<p>Let’s get to it! We'll split the development of this game up into parts. This
first part will ask for input from a user and process the input, checking that
the input is in the form we expect. First we need to allow our player to input
a guess. Enter this in your <code>src/main.rs</code>:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>There’s a lot here! Let’s go over it, bit by bit.</p>
<pre><code class="language-rust,ignore">use std::io;
</code></pre>
<p>We’ll need to take user input and then print the result as output, and for that
functionality we need to import the <code>io</code> (input/output) library from the
standard library (which is known as <code>std</code>).</p>
<p>By default, Rust only imports a few things into every program in <a href="https://doc.rust-lang.org/std/prelude/">the
<em>prelude</em></a><!-- ignore -->. If it’s not in the prelude, you’ll have to
import it into your program explicitly with a <code>use</code> statement. Using the
<code>std::io</code> library gets you a number of useful <code>io</code>-related things, including
the functionality to accept user input.</p>
<pre><code class="language-rust,ignore">fn main() {
</code></pre>
<p>As you’ve seen in Chapter 1, the <code>main()</code> function is the entry point into the
program. The <code>fn</code> syntax declares a new function, the <code>()</code>s indicate that
there are no arguments, and <code>{</code> starts the body of the function.</p>
<pre><code class="language-rust,ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>As we learned in Chapter 1, <code>println!()</code> is a macro that prints a string to the
screen. This is just a prompt stating what the game is and requesting input from
the user.</p>
<h3>Storing Values with Variable Bindings</h3>
<p>Next we need to store the user input.</p>
<pre><code class="language-rust,ignore">let mut guess = String::new();
</code></pre>
<p>Now we’re getting interesting! There’s a lot going on in this little line.
The first thing to notice is that this is a <code>let</code> statement, which is
used to create <em>variable bindings</em>. Here's another example:</p>
<pre><code class="language-rust,ignore">let foo = bar;
</code></pre>
<p>This will create a new binding named <code>foo</code>, and bind it to the value <code>bar</code>. In
many languages, this is called a <em>variable</em>, but Rust’s variable bindings have
a few differences.</p>
<p>For example, they’re immutable by default. To make our binding mutable, our
example uses <code>mut</code> before the binding name.</p>
<pre><code class="language-rust">let foo = 5; // immutable.
let mut bar = 5; // mutable
</code></pre>
<blockquote>
<p>Note: The <code>//</code> syntax will start a comment that continues until the end of the
line. Rust ignores everything in comments.</p>
</blockquote>
<p>So now we know that <code>let mut guess</code> will introduce a mutable binding named
<code>guess</code>, but we have to look at the other side of the <code>=</code> for the value it’s
bound to: <code>String::new()</code>.</p>
<p><code>String</code> is a string type, provided by the standard library. A
<a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> is a growable, UTF-8 encoded bit of text.</p>
<p>The <code>::</code> syntax in the <code>::new()</code> line indicates that <code>new()</code> is an <em>associated
function</em> of a particular type. An associated function is a function that is
associated with a type, in this case <code>String</code>, rather than a particular
instance of a <code>String</code>. Some languages call this a <em>static method</em>.</p>
<p>This <code>new()</code> function creates a new, empty <code>String</code>.
You’ll find a <code>new()</code> function on many types, as it’s a common name for making
a new value of some kind.</p>
<p>So to summarize, the <code>let mut guess = String::new();</code> line has created a
mutable binding that is currently bound to a new, empty instance of a <code>String</code>.
Whew!</p>
<p>Let’s move forward:</p>
<pre><code class="language-rust,ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>Remember how we said <code>use std::io;</code> on the first line of the program? We’re now
calling an associated function on it. If we didn’t <code>use std::io</code>, we could
have written this line as <code>std::io::stdin()</code>.</p>
<p>This function returns an instance of <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->,
which is a type that represents a handle to the standard input for your
terminal.</p>
<p>The next part, <code>.read_line(&amp;mut guess)</code>, calls the
<a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a><!-- ignore --> method on the standard input handle
to get input from the user. We’re also passing one argument to <code>read_line()</code>:
<code>&amp;mut guess</code>.</p>
<p>The job of <code>read_line()</code> is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so that the method can change the string's
content by adding the user input.</p>
<p>The <code>&amp;</code> indicates that this argument is a <em>reference</em>, which gives you a way to
allow multiple parts of your code to access to one piece of data without
needing to copy that data into memory multiple times. References are a complex
feature, and one of Rust’s major advantages is how safe and easy it is to use
references. We don’t need to know a lot of those details to finish our program
right now, though; Chapter XX will cover references in more detail. For now,
all we need to know is that like <code>let</code> bindings, references are immutable by
default. Hence, we need to write <code>&amp;mut guess</code>, rather than <code>&amp;guess</code> to make it
mutable.</p>
<p>We’re not quite done with this line of code. While it’s a single line of text,
it’s only the first part of the single logical line of code. The second part is
this method:</p>
<pre><code class="language-rust,ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p>When you call a method with the <code>.foo()</code> syntax, it's often wise to introduce a
newline and other whitespace. This helps you split up long lines. We <em>could</em>
have written this code as:</p>
<pre><code class="language-rust,ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;failed to read line&quot;);
</code></pre>
<p>But that gets hard to read. So we’ve split it up, two lines for two method
calls. Now let's see what this line does.</p>
<h3>Handling Potential Failure with the <code>Result</code> Type</h3>
<p>We mentioned that <code>read_line()</code> puts what the user types into the string we
pass it, but it also returns a value: in this case, an
<a href="../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust has a number of types named
<code>Result</code> in its standard library: a generic <a href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->,
and then specific versions for sub-libraries, like <code>io::Result</code>.</p>
<p>The <code>Result</code> types are <a href="ch06-00-enums.html">enums</a><!-- ignore -->, which is short for
<em>enumeration</em>. An enumeration is a type that can have a fixed set of values,
which are called the <code>enum</code>'s <em>variants</em>. We will be covering enums in more
detail in Chapter XX.</p>
<p>For <code>Result</code>, the variants are <code>Ok</code> or <code>Err</code>. <code>Ok</code> means the operation was
successful, and inside the <code>Ok</code> variant is the successfully generated value.
<code>Err</code> means the operation failed, and the <code>Err</code> contains information about how
or why the operation failed.</p>
<p>The purpose of these <code>Result</code> types is to encode error handling information.
Values of the <code>Result</code> type, like any type, have methods defined on them. In
this case, <code>io::Result</code> has an <a href="../std/result/enum.Result.html#method.expect"><code>expect()</code> method</a><!-- ignore --> that
we can call. If this instance of <code>io::Result</code> is an <code>Err</code> value, <code>expect()</code>
will cause our program to crash and display the message that we passed as an
argument to <code>expect()</code>. In this case, if the <code>read_line()</code> method returns an
<code>Err</code>, it would likely be the result of an error coming from the underlying
operating system. If this instance of <code>io::Result</code> is an <code>Ok</code> value, <code>expect()</code>
will take the return value that <code>Ok</code> is holding out of the <code>Ok</code> and return just
that value to us so that we can use it. In this case, that value will be what
the user entered into standard input.</p>
<p>If we don't call <code>expect()</code>, our program will compile, but we’ll get a warning:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust warns that we haven’t used the <code>Result</code> value, telling us that we
haven’t handled a possible error. The right way to suppress the warning is to
actually write error handling, but if we just want to crash the program when a
problem occurs, we can use <code>expect()</code>. We’ll save recovering from errors for a
future project.</p>
<h3>Printing Values with <code>println!()</code> Placeholders</h3>
<p>There’s only one line of this first example left, aside from the closing curly
brace:</p>
<pre><code class="language-rust,ignore">    println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<p>This prints out the string we saved our input in. The <code>{}</code>s are a placeholder:
think of <code>{}</code> as little crab pincers, holding a value in place. You can print
more than one value this way: the first <code>{}</code> holds the first value listed after
the format string, the second set holds the second value, and so on. Printing
out multiple values in one call to <code>println!()</code> would then look like this:</p>
<pre><code class="language-rust">let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
</code></pre>
<p>Which would print out &quot;x = 5 and y = 10&quot;.</p>
<h3>Testing the First Part</h3>
<p>Back to our guessing game, let's test what we have so far. We can run it with
<code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>All right! Our first part is done: we can get input from the keyboard and then
print it back out.</p>
<h2>Generating a Secret Number</h2>
<p>Next, we need to generate a secret number that the user is trying to guess. The
secret number should be different every time so that the game is fun to play
more than once. So we'd like to have a random number between 1 and 100. Rust
does not yet include random number functionality in its standard library. The
Rust team does, however, provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>.</p>
<h3>Using a Crate to Get More Functionality</h3>
<p>Remember that <em>crate</em> is what we call a package of Rust code. The project we’ve
been building is a <em>binary crate</em>, which is an executable. The <code>rand</code> crate is
a <em>library crate</em>, which contains code intended to be used in other programs.</p>
<p>Cargo's use of external crates is where it really shines. Before we can write
the code using <code>rand</code>, we need to modify our <code>Cargo.toml</code> to include the <code>rand</code>
crate as a dependency. Open it up, and add this line at the bottom beneath the
<code>[dependencies]</code> section header that Cargo created for you:</p>
<p>Filename: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>In the <code>Cargo.toml</code> file, everything that follows a header is part of a section
that goes until another section starts. Cargo uses the <code>[dependencies]</code> section
to know what external crates your project depends on and what versions of those
crates you require. In this case, we’ve specified the <code>rand</code> crate with the
semantic version specifier <code>0.3.14</code>. Cargo understands <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (sometimes called <em>semver</em>), which is a
standard for writing version numbers. A bare number like above is actually
shorthand for <code>^0.3.14</code>, which means &quot;any version that has a public API
compatible with version 0.3.14&quot;.</p>
<p>Now, without changing any of our code, let’s build our project:</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>You may see different version numbers (but they will all be compatible with
your code, thanks to semver!) and the lines may be in a different order.</p>
<p>Lots of new output! Now that we have an external dependency, Cargo fetches the
latest versions of everything from the <em>registry</em>, which is a copy of data from
<a href="https://crates.io">Crates.io</a>. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.</p>
<p>After updating the registry, Cargo checks our <code>[dependencies]</code> and downloads
any we don’t have yet. In this case, while we only listed <code>rand</code> as a
dependency, we’ve also grabbed a copy of <code>libc</code>, because <code>rand</code> depends on
<code>libc</code> to work. After downloading them, Rust compiles them and then compiles
our project.</p>
<p>If we run <code>cargo build</code> again, we’ll get different output:</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>That’s right, no output! Cargo knows that our project has been built, that
all of its dependencies are built, and that no changes have been made. There’s
no reason to do all that stuff again. With nothing to do, it simply
exits. If we open up <code>src/main.rs</code>, make a trivial change, then save it again,
we’ll only see one line:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>This just updates the build with your tiny change to the <code>main.rs</code> file.</p>
<h4>The Cargo.lock File that Ensures Reproducible Builds</h4>
<p>Cargo has a mechanism to make sure we can rebuild the exact same artifact every
time we or anyone else builds our code: Cargo will only use the versions of the
dependencies you specified until you say otherwise. For example, what happens
if next week version <code>v0.3.15</code> of the <code>rand</code> crate comes out, containing an
important bugfix, but that also contains a regression that will break our code?</p>
<p>The answer to this problem is the <code>Cargo.lock</code> file created the first time we
ran <code>cargo build</code> that is now in your project directory. When you build your
project for the first time, Cargo figures out all of the versions of your
dependencies that fit your criteria then writes them to the <code>Cargo.lock</code> file.
When you build your project in the future, Cargo will see that the <code>Cargo.lock</code>
file exists and use the versions specified there rather than doing all the work
of figuring out versions again. This lets you have a reproducible build
automatically. In other words, our project will stay at <code>0.3.14</code> until we
explicitly upgrade, thanks to the lock file.</p>
<h4>Updating a Crate to Get a New Version</h4>
<p>When we <em>do</em> want to update a crate, Cargo has another command,
<code>update</code>, which will:</p>
<ul>
<li>Ignore the <code>Cargo.lock</code> file and figure out all the latest versions that fit
our specifications in <code>Cargo.toml</code>.</li>
<li>If that works, write those versions out to the lock file.</li>
</ul>
<p>But by default, Cargo will only look for versions larger than <code>0.3.0</code> and
smaller than <code>0.4.0</code>. If the <code>rand</code> crate has released two new versions,
<code>0.3.15</code> and <code>0.4.0</code>, this is what we would see if we ran <code>cargo update</code>:</p>
<pre><code class="language-bash">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>At this point, you would also notice a change in your <code>Cargo.lock</code> file noting
that the version of the <code>rand</code> crate you are now using is <code>0.3.15</code>.</p>
<p>If we wanted to use <code>rand</code> version <code>0.4.0</code> or any version in the <code>0.4.x</code>
series, we’d have to update what is in the <code>Cargo.toml</code> file to look like this
instead:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>The next time we <code>cargo build</code>, assuming that the <code>rand</code> crate version <code>0.4.0</code>
has been released, Cargo will update the crates index and re-evaluate our
<code>rand</code> requirements according to the new version we have specified.</p>
<p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a><!-- ignore --> and <a href="http://doc.crates.io/crates-io.html">its
ecosystem</a><!-- ignore --> that we will get into in Chapter XX, but
for now, that’s all we need to know. Cargo makes it really easy to re-use
libraries, so Rustaceans are able to write smaller projects which are assembled
out of a number of sub-packages.</p>
<h3>Generating a Random Number</h3>
<p>Let’s get on to actually <em>using</em> <code>rand</code>. Our next step is to update our
<code>main.rs</code> code as follows:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>First we've added a line to the top, <code>extern crate rand</code>, that lets Rust know
we’ll be making use of that external dependency. This also does the equivalent
of calling <code>use rand</code>, so we can now call anything in the <code>rand</code> crate by
prefixing it with <code>rand::</code>.</p>
<p>Next, we added another <code>use</code> line: <code>use rand::Rng</code>. <code>Rng</code> is a trait that
defines methods that random number generators implement, and this trait must be
in scope for us to use those methods. We'll cover traits in detail in the
Traits section in Chapter XX.</p>
<p>We also added two more lines in the middle:</p>
<pre><code class="language-rust,ignore">let secret_number = rand::thread_rng().gen_range(1, 101);

println!(&quot;The secret number is: {}&quot;, secret_number);
</code></pre>
<p><code>rand::thread_rng()</code> is a function that will give us the particular random
number generator that we're going to use: one that is local to our current
thread of execution and seeded by the operating system. Next, we call the
<code>gen_range()</code> method on our random number generator. This method is one that is
defined by the Rng trait that we brought into scope with the <code>use rand::Rng</code>
statement above. <code>gen_range()</code> takes two numbers as arguments and generates a
random number between them. It’s inclusive on the lower bound but exclusive on
the upper bound, so we need <code>1</code> and <code>101</code> to ask for a number ranging from one
to a hundred.</p>
<p>Knowing what traits to import and what functions and methods to use from a
crate isn't something that you'll just <em>know</em>. Instructions for using a crate
are in each crate's documentation. Another neat feature of Cargo is that you
can run the <code>cargo doc --open</code> command to build documentation provided by all
of your dependencies locally and then open it in your browser. If you're
interested in other functionality in the <code>rand</code> crate, for example, run <code>cargo doc --open</code> then click on &quot;rand&quot; in the sidebar on the left.</p>
<p>The second line that we added to our code prints out the secret number. This is
useful while we’re developing our program to let us easily test it out, but
we’ll be deleting it for the final version. It’s not much of a game if it
prints out the answer when you start it up!</p>
<p>Try running our new program a few times:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>You should get different random numbers, and they should all be numbers between
1 and 100. Great job!</p>
<h2>Comparing Our Guesses</h2>
<p>Now that we’ve got user input, let’s compare our guess to the secret number.
Here’s that part of our next step:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>There are a few new bits here. The first is another <code>use</code>, bringing a type
called <code>std::cmp::Ordering</code> into scope from the standard crate. <code>Ordering</code> is
another enum, like <code>Result</code>, but the variants for <code>Ordering</code> are <code>Less</code>,
<code>Greater</code>, and <code>Equal</code>. These are the three outcomes that are possible when you
compare two things.</p>
<p>Then we add five new lines at the bottom that use the <code>Ordering</code> type:</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p>The <code>cmp()</code> method compares two values, and can be called on anything that can
be compared. It takes a reference to the thing you want to compare it to, so
here it's comparing our <code>guess</code> to our <code>secret_number</code>, and it returns a
variant of the <code>Ordering</code> enum. We use a <a href="match.html"><code>match</code></a><!-- ignore -->
statement to decide what to do next based on which variant of <code>Ordering</code> we got
back.</p>
<p><code>match</code> statements are made up of <em>arms</em>. An arm consists of a <em>pattern</em> and
the code that we should run if the value given to the beginning of the <code>match</code>
statement fits that arm's pattern. Rust takes the value given to <code>match</code> and
looks through each arm's pattern in turn. The <code>match</code> construct and patterns
are powerful features in Rust that will be covered in detail in Chapter XX and
Chapter XX, respectively.</p>
<p>Let's walk through an example of what would happen with our <code>match</code>. Say that
the user has guessed 50, and the randomly-generated secret number this time
is 38. So when we compare 50 to 38, the <code>cmp()</code> method will return
<code>Ordering::Greater</code>, since 50 is greater than 38. <code>Ordering::Greater</code> is the
value that the <code>match</code> statement gets. It looks at the first arm's pattern,
<code>Ordering::Less</code>, and says nope, the value we have (<code>Ordering::Greater</code>) does
not match <code>Ordering::Less</code>. So it ignores the code in that arm and moves on to
the next arm. The next arm's pattern, <code>Ordering::Greater</code>, <strong>does</strong> match
<code>Ordering::Greater</code>! The associated code in that arm will get executed, which
prints &quot;Too big!&quot; to the screen. Then we're done with the <code>match</code> statement; we
don't look at the last arm at all in this particular scenario.</p>
<p>However, this code won’t quite compile yet. Let’s try it:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
src/main.rs:23:21: 23:35 error: mismatched types [E0308]
src/main.rs:23     match guess.cmp(&amp;secret_number) {
                                   ^~~~~~~~~~~~~~
src/main.rs:23:21: 23:35 help: run `rustc --explain E0308` to see a detailed explanation
src/main.rs:23:21: 23:35 note: expected type `&amp;std::string::String`
src/main.rs:23:21: 23:35 note:    found type `&amp;_`
error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>Whew! This is a big error. The core of the error says that we have <em>mismatched
types</em>. Rust has a strong, static type system. However, it also has type
inference. When we wrote <code>let guess = String::new()</code>, Rust was able to infer
that <code>guess</code> should be a <code>String</code> and didn’t make us write the type out. Our
<code>secret_number</code> on the other hand is a number type. There are a few number
types which can have a value between one and a hundred: <code>i32</code>, a thirty-two-bit
number; or <code>u32</code>, an unsigned thirty-two-bit number; <code>i64</code>, a sixty-four-bit
number; or others. Rust defaults to an <code>i32</code>, so that's the type of
<code>secret_number</code> unless we add type information elsewhere that would cause Rust
to infer a different numerical type. The error is because Rust will not compare
a string and a number type.</p>
<p>Ultimately, we want to convert the <code>String</code> we read as input
into a real number type so that we can compare it to the guess numerically. We
can do that with two more lines; add this to your program:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>The two new lines are:</p>
<pre><code class="language-rust,ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>We create a variable binding <code>guess</code>. But wait a minute, don't we already have
a variable binding named <code>guess</code>? We do, but Rust allows us to <em>shadow</em> the
previous value of <code>guess</code> with a new one. This is often used in this exact
situation, where we want to convert a value from one type into another type.
Shadowing lets us re-use the <code>guess</code> variable name rather than forcing us to
come up with two unique bindings, like <code>guess_str</code> and <code>guess</code> or something.</p>
<p>We bind <code>guess</code> to the expression <code>guess.trim().parse()</code>.</p>
<p>The <code>guess</code> in the expression refers to the original <code>guess</code> that was a
<code>String</code> with our input in it. The <code>trim()</code> method on <code>String</code>s will eliminate
any white space at the beginning and end. Our u32 can only contain numerical
characters, but we have to press the &quot;return&quot; key to satisfy <code>read_line()</code>.
When we press the return key, it introduces a newline character. For example,
if we type <code>5</code> and hit return, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code>
represents &quot;newline&quot;, the return key. The <code>trim()</code> method gets rid of this,
leaving our string with only the <code>5</code>.</p>
<p>The <a href="../std/primitive.str.html#method.parse"><code>parse()</code> method on strings</a><!-- ignore --> parses a string into
some kind of number. Since this method can parse a variety of number types, we
need to tell Rust the exact type of number we want with <code>let guess: u32</code>. The
colon (<code>:</code>) after <code>guess</code> tells Rust we’re going to annotate its type. Rust has
a few built-in number types, but we’ve chosen <code>u32</code>, an unsigned, thirty-two
bit integer. It’s a good default choice for a small positive number.
Additionally, our <code>u32</code> annotation here and the comparison with <code>secret_number</code>
means that Rust will infer that <code>secret_number</code> should be a <code>u32</code> as well. So
now the comparison will be between two values of the same type!</p>
<p>There's just one remaining piece to handle: our call to <code>parse()</code> could quite
easily cause an error, if, for example, our string contained <code>A👍%</code>; there’d be
no way to convert that to a number. Because it might fail, the <code>parse()</code> method
returns a <code>Result</code> type, much like the <code>read_line()</code> method does that we
discussed earlier. We're going to treat this <code>Result</code> the same way by using the
<code>expect()</code> method again. If <code>parse()</code> returns an <code>Err</code> <code>Result</code> variant because
it could not create a number from the string, the <code>expect()</code> call will crash
the game and print the message we give it. If <code>parse()</code> can successfully turn
the string into a number, it will return the <code>Ok</code> variant of <code>Result</code>, and
<code>expect()</code> will return the number that we want that it will take out of the
<code>Ok</code> value for us.</p>
<p>Let’s try our program out!</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! You can see we even added spaces before our guess, and it still figured
out that we guessed 76. Run the program a few times to verify the different
behavior with different kinds of input: guess the number correctly, guess a
number that is too high, and guess a number that is too low.</p>
<p>Now we’ve got most of the game working, but we can only make one guess. Let’s
change that by adding a loop!</p>
<h2>Allowing Multiple Guesses with Looping</h2>
<p>The <code>loop</code> keyword gives us an infinite loop. We'll add that in to give us more
chances at guessing the number:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>As you can see, we've moved everything from the guess input onwards into a
loop. Make sure to indent those lines another four spaces each, and try it out.
You'll notice we have a new problem because the program is doing exactly what we
told it to do: ask for another guess forever! It doesn't seem like we can quit!</p>
<p>We could always halt the program by using the keyboard shortcut <code>control-c</code>.
There's another way to escape the monster we've created that will infinitely
demand more guesses, though, that can be found in our discussion about
<code>parse()</code>: if we give a non-number answer, the program will crash. We can use
that to quit! Observe:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p>This method means that typing <code>quit</code> actually quits the game, but so does any
other non-number input. This is suboptimal, to say the least. We want the game
to automatically stop when the correct number is guessed.</p>
<h4>Quitting When you Win</h4>
<p>Let’s program the game to quit when you win by adding a <code>break</code> in that case:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>By adding the <code>break</code> line after <code>You win!</code>, we’ll exit the loop when we guses
the secret number correctly. Exiting the loop also means exiting the program,
since the loop is the last thing in <code>main()</code>.</p>
<h4>Handling Invalid Input</h4>
<p>For our final refinement of the game's behavior, rather than crashing the
program when someone inputs a non-number, we want the game to ignore it so we
can continue guessing. We can do that by altering the line where we convert
<code>guess</code> from a <code>String</code> to a <code>u32</code>:</p>
<pre><code class="language-rust,ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>This is how you generally move from &quot;crash on error&quot; to &quot;actually handle the
error&quot;: by switching from an <code>expect()</code> statement to a <code>match</code> statement.
Remember that <code>parse()</code> returns a <code>Result</code> type, and <code>Result</code> is an enum that
has the variants <code>Ok</code> or <code>Err</code>. We're going to use a <code>match</code> statement here,
like we did with the <code>Ordering</code> result of the <code>cmp()</code> method.</p>
<p>If <code>parse()</code> is able to successfully turn the string into a number, it will
return an <code>Ok</code> value that contains the resulting number. That <code>Ok</code> value will
match the first arm's pattern, and the match statement will just return the
<code>num</code> value that <code>parse()</code> produced and put inside the <code>Ok</code> value. That number
will end up right where we want it, in the new <code>guess</code> binding we're creating.</p>
<p>If <code>parse()</code> is <em>not</em> able to turn the string into a number, it will return an
<code>Err</code> value that contains more information about the error. The <code>Err</code> value
does not match the <code>Ok(num)</code> pattern in the first match arm, but it does match
the <code>Err(_)</code> pattern in the second arm. The <code>_</code> is a catch-all value; we're
saying we want to match all <code>Err</code> values, no matter what information they have
inside them. So we execute the second arm's code, <code>continue</code>: this means to go
to the next iteration of the <code>loop</code> and ask for another guess. So we have
effectively ignored all errors that <code>parse()</code> might hit!</p>
<p>Now everything in our program should work as we expect it to! Let’s try it:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny last tweak, we can finish the guessing game: we're still
printing out the secret number. That was good for testing, but it kind of ruins
the game. Let's delete the <code>println!</code> that outputs the secret number. Here’s our
full, final code:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h2>Complete!</h2>
<p>At this point, you have successfully built the Guessing Game! Congratulations!</p>
<p>This project was a hands-on way to introduce you to a lot of new Rust concepts:
<code>let</code>, <code>match</code>, methods, associated functions, using external crates, and more.
In the next few chapters, we will go through these concepts in more detail.
Chapter 3 covers concepts that most programming languages have, like variables,
data types, and functions, and shows how to use them in Rust. Chapter 4 gets
into ownership, which is the feature of Rust that is most different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
endeavors to explain enums.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch01-02-hello-world.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch03-00-common-programming-concepts-in-rust.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch01-02-hello-world.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch03-00-common-programming-concepts-in-rust.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
